---
description: Learnings from implementing the search feature in viberatr
tags: search, command-palette, frontend, backend, fuzzy-search, filters
---

# Search Feature Implementation Learnings

## Agent 2: Advanced Search & Filters Learnings

### Context
These learnings are from implementing advanced search features including fuzzy matching, filtering, and UI components for the viberatr project.

## Key Insights

### 1. Type Definitions First
- The search types in `packages/types/src/search.ts` provide a solid foundation
- All components should import from `@viberatr/types` for consistency
- The types are already exported from the package index

### 2. Command Palette Integration
- shadcn's Command component is already installed and configured
- The component uses `cmdk` under the hood for keyboard navigation
- Dialog wrapper provides modal behavior out of the box

### 3. Route Navigation
- Use `useNavigate()` from `@tanstack/react-router` for programmatic navigation
- Available routes: `/vibes/create`, `/profile`, `/search`, etc.
- Route params use the `params` object, search params use `search` object

### 4. Mock Data Strategy
- Create comprehensive mock data that matches type definitions exactly
- Include all fields to avoid TypeScript errors
- Use type predicates for filtering: `(r: any): r is VibeSearchResult`

### 5. Header Integration Pattern
- Global keyboard shortcuts should be registered at the header level
- Use `useState` for dialog open state
- Clean up existing search UI when replacing with command palette

## Common Pitfalls to Avoid

### 1. Don't Run Dev Servers Without Timeout
- Never run `bun run dev` without proper process management
- Use build commands to verify implementation instead
- If dev server check is needed, use timeout and kill the process

### 2. File Creation Order
- Always create parent directories first
- Use `touch` command before writing to new files
- Check if UI components exist before trying to install them

### 3. Type Imports
- Import types from `@viberatr/types`, not relative paths
- The search types are already exported from the package
- Use type imports when only importing types: `import type { ... }`

## Useful Patterns

### Search Hook with Mock Data
```typescript
export function useSearchSuggestions(query: string) {
  const [isLoading, startTransition] = useTransition();
  const [data, setData] = useState<ReturnType<typeof getMockSearchSuggestions> | null>(null);

  const fetchSuggestions = useCallback((searchQuery: string) => {
    if (!searchQuery.trim()) {
      setData(null);
      return;
    }

    startTransition(() => {
      const suggestions = getMockSearchSuggestions(searchQuery);
      setData(suggestions);
    });
  }, []);

  // Auto-fetch when query changes
  if (query !== (data ? query : '')) {
    fetchSuggestions(query);
  }

  return { data, isLoading };
}
```

### Result Component Pattern
```typescript
interface ResultProps {
  result: SearchResultType;
  onSelect?: () => void;
}

export function Result({ result, onSelect }: ResultProps) {
  const navigate = useNavigate();

  const handleSelect = () => {
    navigate({ to: '/route', params: { id: result.id } });
    onSelect?.();
  };

  return (
    <CommandItem onSelect={handleSelect}>
      {/* Result content */}
    </CommandItem>
  );
}
```

## Integration Points

### When Backend is Ready
1. Replace mock data functions with Convex queries
2. Update hooks to use `useQuery` from Convex
3. Add error handling and loading states
4. Implement search tracking mutations

### For Search Results Page
- The command palette links to `/search?q={query}`
- Results page will receive query from URL params
- Filter sidebar will be provided by Agent 4

## Testing Recommendations
1. Test keyboard navigation thoroughly
2. Verify all result types render correctly
3. Check mobile responsiveness
4. Test with empty states and no results
5. Verify navigation to all linked pages

## Agent 2 Specific Learnings

### 1. Fuzzy Search Implementation
- **Approach**: Implemented Levenshtein distance algorithm for typo tolerance
- **Performance**: Limited initial queries to 500 vibes and 200 users to prevent performance issues
- **Threshold**: Used 0.7 as default similarity threshold for fuzzy matching
- **Tip**: For longer queries (4+ chars), use sliding window approach for substring matching

### 2. Search Operators
- **Pattern**: Use regex to parse operators before processing search text
- **Order matters**: Extract exact phrases first, then filters, then process remaining terms
- **Operators implemented**:
  - `"exact phrase"` - Exact matching
  - `-term` - Exclusion
  - `#tag` - Tag filtering
  - `@username` - User filtering
  - `rating:>4` - Rating filters
  - `date:>2024-01-01` - Date filters

### 3. Convex Search Optimization
- **Index usage**: Always prefer indexes over filters for performance
- **Limits**: Use `.take()` to limit initial queries before filtering
- **Batching**: Get related data (ratings, users) in batches rather than per-item
- **Async metrics**: Use `ctx.scheduler.runAfter()` to record metrics without blocking response

### 4. Filter Components
- **State management**: Create dedicated hook (`use-filter-state`) for URL synchronization
- **Mobile**: Always implement mobile drawer/sheet for filters on small screens
- **Active filters**: Show active filter badges for better UX
- **Presets**: Include common presets (e.g., "4+ stars", "Last 7 days") for quick filtering

### 5. URL State Synchronization
- **Approach**: Use URLSearchParams with TanStack Router's useSearchParams
- **Serialization**: Join arrays with commas, use standard formats for dates
- **Defaults**: Don't include default values in URL to keep it clean

### 6. Component Structure
- **Separation**: Keep enhanced versions in separate files (e.g., `tag-filter-enhanced.tsx`)
- **Composition**: Build complex filters from smaller, focused components
- **Icons**: Use Lucide React icons consistently throughout filter UI

## When to Apply These Learnings

### Use fuzzy search when:
- Users might make typos
- You want forgiving search behavior
- Exact matching is too restrictive

### Use search operators when:
- Power users need advanced search
- Complex filtering is required
- Building developer-focused tools

### Use URL sync when:
- Search results need to be shareable
- Users navigate back/forward frequently
- SEO is important

### Use mobile drawers when:
- Filters take significant space
- Mobile experience is important
- You have 3+ filter types

## Common Pitfalls to Avoid

1. **Don't fetch all records** - Always limit queries before filtering
2. **Don't parse operators after fuzzy matching** - Parse first, then apply fuzzy logic
3. **Don't forget mobile** - Test filter UI on small screens
4. **Don't skip loading states** - Users need feedback during search
5. **Don't ignore URL length** - Long filter URLs can break in some browsers
6. **Don't block on metrics** - Use async scheduling for analytics

## Future Improvements

1. **Search suggestions** - Show popular searches or corrections
2. **Search analytics** - Track what users search for
3. **Saved searches** - Let users save complex filter combinations
4. **Search history** - Show recent searches for quick access
5. **Faceted search** - Show counts for each filter option
6. **Elasticsearch integration** - For even more advanced search capabilities