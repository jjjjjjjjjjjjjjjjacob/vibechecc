# Search Integration Learnings

## Context
These learnings come from implementing the real-time search integration (Agent 1's work) for the vibechecc project.

## Key Learnings

### 1. Debouncing Strategy
- Use 300ms debouncing for main search queries to balance responsiveness and performance
- Use 150ms for instant search suggestions (faster feedback needed)
- Create a reusable `useDebouncedValue` hook for consistency

### 2. Convex Query Integration
- Always check if query data exists before using in effects to avoid race conditions
- Track search requires both `query` and `resultCount` parameters
- Use `convexQuery` from `@convex-dev/react-query` for proper integration

### 3. Search Tracking
- Only track searches when debounced query changes AND data is available
- This prevents tracking incomplete searches and reduces noise in analytics
- Example pattern:
  ```typescript
  useEffect(() => {
    if (debouncedQuery.trim() && searchQuery.data) {
      trackSearchMutation.mutate({ 
        query: debouncedQuery,
        resultCount: searchQuery.data.totalCount || 0,
      });
    }
  }, [debouncedQuery, searchQuery.data]);
  ```

### 4. Command Palette Data Format
- Trending searches from API need conversion to `SearchSuggestion` format
- Recent searches come as string arrays from API, need formatting
- Always handle null/undefined cases with fallbacks

### 5. Error Handling Pattern
- Create dedicated error and loading components for reusability
- Pass error state through props to display components
- Include retry functionality for better UX

### 6. Type Safety
- Import types from `@vibechecc/types` for consistency
- Use proper type guards when checking for specific result types
- Handle union types carefully in search results

### 7. Performance Considerations
- Implement search caching with 15-minute cache time
- Use 5-minute stale time for better perceived performance
- Prefetch functionality should be available but not automatic

## When to Reference This
- When implementing new search features
- When debugging search performance issues
- When adding new search result types
- When modifying the command palette
- When implementing similar real-time features

## Common Pitfalls Avoided
1. Not debouncing search input (causes excessive API calls)
2. Tracking searches before results are available
3. Not handling empty/null states in suggestions
4. Forgetting to format API responses for UI components
5. Missing error boundaries in search components