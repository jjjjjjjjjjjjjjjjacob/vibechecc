# Backend Search Implementation Learnings

## Context
While implementing the backend search infrastructure for viberater (Agent 1 task), several important patterns and considerations emerged.

## Key Learnings

### 1. Convex Schema Updates
- When adding new tables to `schema.ts`, remember to export the validator types
- Use meaningful index names that describe the query pattern (e.g., 'byUser', 'byCount')
- Consider compound indexes for queries that filter by multiple fields

### 2. Type Imports from Shared Packages
- The `@viberater/types` package exports search-related types
- Import types directly: `import type { SearchResult, ... } from '@viberater/types'`
- Types are automatically available after the package is built

### 3. Convex Query Patterns
- Prefer indexes over filters for performance
- Use `.withIndex()` for efficient queries
- Limit results early with `.take()` to avoid loading unnecessary data
- Remember that Convex queries are reactive by default

### 4. Search Implementation Strategies
- **Relevance Scoring**: Implement a scoring system that weights:
  - Exact matches (highest score)
  - Contains full query
  - Contains all words
  - Individual word matches
- **Performance**: For command palette suggestions, limit database queries:
  - Use `.take()` to limit initial results
  - Break loops early when limits are reached
  - Avoid nested queries in loops where possible

### 5. Authentication in Convex
- Use `ctx.auth.getUserIdentity()` to get current user
- The user ID is available as `identity.subject`
- Always check for authentication before user-specific operations

### 6. Convex Code Generation
- Run `bun convex codegen` in the backend directory after schema changes
- This generates TypeScript types for your tables and functions
- Generated files are in `convex/_generated/`

### 7. Internal Function Calls
- Avoid recursive calls to query functions
- If needed, use `internalQuery` and `ctx.runQuery(internal.namespace.function)`
- For the search implementation, inline logic was more efficient than internal calls

## Common Pitfalls to Avoid
1. Don't use `.eq('field', undefined)` in index queries - it will fail
2. Remember to handle optional fields with proper null checks
3. Type imports must match exactly what's exported from the types package
4. Convex timestamps are numbers (milliseconds), not Date objects

## Useful Patterns

### Efficient Tag Aggregation
```typescript
const tagCounts = new Map<string, number>();
vibes.forEach(vibe => {
  vibe.tags?.forEach(tag => {
    tagCounts.set(tag, (tagCounts.get(tag) || 0) + 1);
  });
});
```

### Search Result Limiting
```typescript
for (const item of items) {
  if (results.length >= limit) break;
  // Process item
}
```

### Safe User Display Names
```typescript
const displayName = user.username || 
  `${user.first_name || ''} ${user.last_name || ''}`.trim() || 
  'Unknown user';
```

## When This Is Helpful
- Implementing new Convex query functions
- Adding search functionality to other collections
- Optimizing database queries for performance
- Working with user authentication in Convex
- Building command palette or autocomplete features