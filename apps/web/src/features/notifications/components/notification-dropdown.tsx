import * as React from 'react'; // bring in the entire React namespace for hooks and types
import { useState, useEffect } from 'react'; // state and lifecycle management helpers
import { Button } from '@/components/ui/button'; // shared button component with app styling
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu'; // primitives for accessible dropdowns
import { ScrollArea } from '@/components/ui/scroll-area'; // scrollable container with consistent styling
import { Loader2 } from 'lucide-react'; // spinner icon shown during async operations
import {
  useNotificationsInfinite,
  useUnreadNotificationCountByType,
  useMarkAllNotificationsAsReadMutation,
} from '@/queries'; // autogenerated Convex React hooks for notification data
import {
  NotificationFilters,
  type NotificationFilterType,
} from './notification-filters'; // filter pills that switch notification types
import { NotificationItem } from './notification-item'; // individual notification entry renderer
import { NotificationEmptyState } from './notification-empty-state'; // placeholder when no notifications exist
import { useInView } from 'react-intersection-observer'; // intersection observer for infinite loading
import { useConvex } from 'convex/react'; // convex client context to know if backend is available

/**
 * Props accepted by {@link NotificationDropdown}.
 * @property open - whether the dropdown menu is currently visible
 * @property onOpenChange - callback fired when visibility toggles
 * @property children - element used as the dropdown trigger
 */
interface NotificationDropdownProps {
  open: boolean; // controls open state from parent
  onOpenChange: (open: boolean) => void; // informs parent of open state changes
  children: React.ReactNode; // trigger element (usually an icon button)
}

// Map UI filter names to backend filter values used by the Convex query
const FILTER_TYPE_MAP = {
  all: undefined, // show all notifications
  likes: 'rating' as const, // filter to vibe reactions
  comments: 'new_rating' as const, // filter to rating comments
  mentions: undefined, // placeholder for future mentions feature
  followers: 'follow' as const, // filter to follow events
};

/**
 * Returns a friendly message when the user reaches the end of the
 * notification list for a given filter.
 * @param filter - currently active notification filter
 */
function getEndOfListMessage(filter: NotificationFilterType): string {
  switch (filter) {
    case 'all':
      return "you're up to date"; // generic fallback for all notifications
    case 'likes':
      return 'no more likes'; // end-of-list message for reactions
    case 'comments':
      return 'no more comments'; // message for comment filter
    case 'mentions':
      return 'no more mentions'; // message for mentions once implemented
    case 'followers':
      return 'no more follows'; // message for follow events
    default:
      return "you're up to date"; // default fallback
  }
}

/**
 * Dropdown menu that displays a user's notifications and supports
 * filtering and infinite scroll loading.
 */
export function NotificationDropdown({
  open,
  onOpenChange,
  children,
}: NotificationDropdownProps) {
  // current active filter pill
  const [activeFilter, setActiveFilter] =
    useState<NotificationFilterType>('all');
  // track whether the viewport is mobile sized
  const [isMobile, setIsMobile] = useState(false);
  // ref passed to sentinel element and boolean that indicates if it's visible
  const { ref: loadMoreRef, inView } = useInView();

  // access convex client; if missing we skip data fetching
  const convex = useConvex();
  const convexAvailable = !!convex; // boolean flag for availability

  // on mount, load the saved filter preference from localStorage
  useEffect(() => {
    if (!convexAvailable) return; // skip when offline/server
    const savedFilter = localStorage.getItem('viberatr-notification-filter');
    if (
      savedFilter &&
      ['all', 'likes', 'comments', 'mentions', 'followers'].includes(
        savedFilter
      )
    ) {
      setActiveFilter(savedFilter as NotificationFilterType); // restore previous choice
    }
  }, [convexAvailable]);

  // persist the chosen filter so it survives refreshes
  useEffect(() => {
    if (!convexAvailable) return; // avoid touching storage without convex
    localStorage.setItem('viberatr-notification-filter', activeFilter);
  }, [activeFilter, convexAvailable]);

  // detect if the screen is below the mobile breakpoint
  useEffect(() => {
    const checkMobile = () => setIsMobile(window.innerWidth < 768); // compare width
    checkMobile(); // run once on mount
    window.addEventListener('resize', checkMobile); // update on resize
    return () => window.removeEventListener('resize', checkMobile); // clean up
  }, []);

  // fetch paginated notifications using the active filter
  const notificationQuery = useNotificationsInfinite(
    FILTER_TYPE_MAP[activeFilter],
    { enabled: open && convexAvailable } // fetch only when dropdown open and convex ready
  );

  // query unread counts grouped by notification type for badges
  const { data: unreadCountsByType } = useUnreadNotificationCountByType({
    enabled: convexAvailable,
  });
  // mutation used to mark all notifications as read
  const markAllAsReadMutation = useMarkAllNotificationsAsReadMutation();

  // when sentinel becomes visible, load the next page of notifications
  useEffect(() => {
    if (
      !convexAvailable ||
      !inView ||
      !notificationQuery.hasNextPage ||
      notificationQuery.isFetchingNextPage ||
      notificationQuery.isLoading
    ) {
      return; // do nothing if any condition prevents fetching
    }
    notificationQuery.fetchNextPage(); // request more notifications
  }, [convexAvailable, inView, notificationQuery]);

  // flatten all paginated pages into a single array of notifications
  const notifications = React.useMemo(() => {
    if (!notificationQuery.data?.pages) return []; // no data yet
    return notificationQuery.data.pages.flatMap(
      (page: any) => page?.notifications || [] // fall back to empty array per page
    );
  }, [notificationQuery.data]);

  // if the convex client isn't ready, render only the trigger to avoid errors
  if (!convexAvailable) {
    return <>{children}</>; // child acts as button without menu
  }

  // compute unread counts for each filter to show badges in the UI
  const unreadCounts = unreadCountsByType
    ? {
        all: Object.values(unreadCountsByType).reduce(
          (sum: number, count: number) => sum + count,
          0 // sum all counts for overall total
        ),
        likes: unreadCountsByType.rating || 0, // unread reactions
        comments: unreadCountsByType.new_rating || 0, // unread comments
        mentions: 0, // mentions not yet supported
        followers: unreadCountsByType.follow || 0, // unread follows
      }
    : undefined; // undefined when counts haven't loaded

  // mark every notification as read via Convex mutation
  const handleMarkAllAsRead = () => {
    markAllAsReadMutation.mutate({});
  };

  // build the dropdown body once to avoid recreating on each render
  const content = (
    <div className="flex h-full flex-col">
      <div className="flex items-center justify-between p-3">
        <h2 className="text-lg font-semibold lowercase">notifications</h2>
        <Button
          variant="ghost"
          size="sm"
          className="h-8 px-2 text-xs lowercase"
          onClick={handleMarkAllAsRead}
          disabled={!unreadCounts?.all}
        >
          mark all read
        </Button>
      </div>

      <NotificationFilters
        activeFilter={activeFilter} // which filter pill is active
        onFilterChange={setActiveFilter} // update active filter when pill clicked
        unreadCounts={unreadCounts} // pass unread counts for badges
      />

      <ScrollArea className="flex-1 overflow-y-auto"> // allow scrolling of long lists
        <div className="min-h-0"> // wrapper to ensure ScrollArea works
          {notificationQuery.isLoading ? (
            <div className="flex items-center justify-center py-8">
              <div className="text-muted-foreground text-sm">
                loading notifications...
              </div>
            </div>
          ) : notifications.length === 0 ? (
            <NotificationEmptyState filter={activeFilter} /> // show empty state when no notifications
          ) : (
            <div className="divide-border/50 divide-y"> // separator between notification items
              {notifications.map((notification) => (
                <NotificationItem
                  key={notification._id} // stable key for list rendering
                  notification={notification} // pass full notification record
                  onClick={() => onOpenChange(false)} // close dropdown when clicking an item
                />
              ))}
              {notificationQuery.hasNextPage ? (
                <div
                  ref={loadMoreRef} // intersection observer target for infinite scroll
                  className="flex items-center justify-center py-4"
                >
                  {notificationQuery.isFetchingNextPage ? (
                    <div className="text-muted-foreground text-sm">
                      loading more...
                    </div>
                  ) : (
                    <Button
                      variant="ghost"
                      size="sm"
                      onClick={() => {
                        if (
                          notificationQuery.hasNextPage &&
                          !notificationQuery.isFetchingNextPage
                        ) {
                          notificationQuery.fetchNextPage(); // manual load more
                        }
                      }}
                      className="text-xs lowercase"
                      disabled={
                        !notificationQuery.hasNextPage ||
                        notificationQuery.isFetchingNextPage
                      }
                    >
                      load more
                    </Button>
                  )}
                </div>
              ) : notifications.length > 0 ? (
                <div className="flex flex-col items-center justify-center space-y-2 py-4">
                  <div className="text-muted-foreground text-xs">
                    {getEndOfListMessage(activeFilter)}
                  </div>
                  <Button
                    variant="ghost"
                    size="sm"
                    onClick={() => notificationQuery.refetch()} // allow manual refresh
                    className="min-w-16 text-xs lowercase"
                    disabled={notificationQuery.isRefetching}
                  >
                    {notificationQuery.isRefetching ? (
                      <Loader2 className="mr-1 h-3 w-3 animate-spin" /> // spinner while refetching
                    ) : (
                      'refresh'
                    )}
                  </Button>
                </div>
              ) : null}
            </div>
          )}
        </div>
      </ScrollArea>
    </div>
  );

  // On mobile we don't show the dropdown shell, just the trigger
  if (isMobile) {
    return <>{children}</>;
  }

  // otherwise render as a dropdown menu
  return (
    <DropdownMenu open={open} onOpenChange={onOpenChange}>
      <DropdownMenuTrigger asChild>{children}</DropdownMenuTrigger>
      <DropdownMenuContent className="w-96 p-0" align="end" sideOffset={8}>
        <div className="h-96">{content}</div>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}
