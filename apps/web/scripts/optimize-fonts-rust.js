#!/usr/bin/env node

/**
 * Fast Font Optimization using Rust-based tools
 * Much faster than Python fonttools
 */

import { execSync } from 'child_process';
import { existsSync, mkdirSync, writeFileSync } from 'fs';
import { join, dirname, basename, extname } from 'path';
import { fileURLToPath } from 'url';

const __dirname = dirname(fileURLToPath(import.meta.url));
const PUBLIC_FONTS_DIR = join(__dirname, '../public/fonts');
const OPTIMIZED_FONTS_DIR = join(PUBLIC_FONTS_DIR, 'optimized');
const CSS_OUTPUT = join(__dirname, '../src/styles/fonts.css');

// Font configurations (same as before)
const FONTS = [
  {
    name: 'GeistSans',
    file: 'GeistSans-Variable.woff2',
    weight: '100 900',
    style: 'normal',
    subset: 'latin',
    fallback: 'system-ui, -apple-system, sans-serif',
  },
  {
    name: 'GeistMono',
    file: 'GeistMono-Variable.woff2',
    weight: '100 900',
    style: 'normal',
    subset: 'latin',
    fallback: 'ui-monospace, monospace',
  },
  {
    name: 'Doto',
    file: 'Doto-VariableFont_ROND,wght.ttf',
    weight: '100 900',
    style: 'normal',
    subset: 'latin',
    fallback: 'system-ui, sans-serif',
  },
];

function checkRustTools() {
  const tools = {
    subfont: checkCommand('subfont --version', 'npm install -g subfont'),
    woff2: checkCommand(
      'woff2_compress --version 2>&1',
      'cargo install woff2-cli'
    ),
    fonttools: checkCommand(
      'fonttools --help 2>&1',
      'cargo install fonttools-cli'
    ),
  };

  // Check for any available tools
  return tools;
}

function checkCommand(cmd, installCmd) {
  try {
    execSync(cmd, { stdio: 'ignore' });
    return true;
  } catch {
    return installCmd;
  }
}

function installRustFontTools() {
  // console.log('📦 Installing Rust font optimization tools...\n');

  try {
    // Install woff2 CLI tool via npm (it's actually a native binary)
    // console.log('Installing woff2 tools...');
    execSync('npm install -g woff2', { stdio: 'inherit' });

    // console.log('\n✅ Rust tools installed successfully!');
    return true;
  } catch {
    // console.error('❌ Failed to install tools:', error.message);
    return false;
  }
}

function optimizeFontFast(inputPath, outputPath) {
  const ext = extname(inputPath).toLowerCase();
  const outputExt = extname(outputPath).toLowerCase();

  // If already WOFF2, just copy
  if (ext === '.woff2' && outputExt === '.woff2') {
    execSync(`cp "${inputPath}" "${outputPath}"`);
    return true;
  }

  try {
    // Convert TTF/OTF to WOFF2 using woff2_compress
    if (ext === '.ttf' || ext === '.otf') {
      // First convert to WOFF2
      const tempWoff2 = outputPath.replace(/\.[^.]+$/, '.woff2');
      execSync(`woff2_compress "${inputPath}" -o "${tempWoff2}"`, {
        stdio: 'pipe',
      });

      if (outputPath !== tempWoff2) {
        execSync(`mv "${tempWoff2}" "${outputPath}"`);
      }

      return true;
    }
  } catch {
    // console.error(`Failed to optimize ${basename(inputPath)}:`, error.message);
    return false;
  }
}

function optimizeEmojiFont() {
  const emojiInput = join(PUBLIC_FONTS_DIR, 'NotoColorEmoji-Regular.ttf');

  if (!existsSync(emojiInput)) {
    // console.warn('⚠️  Emoji font not found');
    return { core: false, extended: false };
  }

  // console.log('\n😀 Processing emoji font (this may take a moment)...');

  // For emoji fonts, we'll use a simpler approach
  // Just copy the original file for now since subsetting color emoji fonts is complex
  const coreOutput = join(OPTIMIZED_FONTS_DIR, 'noto-color-emoji-core.ttf');
  const extendedOutput = join(
    OPTIMIZED_FONTS_DIR,
    'noto-color-emoji-extended.ttf'
  );

  try {
    // For now, copy the full font as "core"
    // In production, you'd want to use a proper emoji subsetting tool
    execSync(`cp "${emojiInput}" "${coreOutput}"`);

    // Create empty extended file
    writeFileSync(extendedOutput, '');

    // console.log('✅ Emoji fonts processed');
    return { core: true, extended: true };
  } catch {
    // console.error('❌ Failed to process emoji font:', error.message);
    return { core: false, extended: false };
  }
}

function generateFontFaceCSS(fonts, emojiCore) {
  let css = `/* Optimized Font Loading - Generated by optimize-fonts-rust.js */\n\n`;

  // Add font-face rules for text fonts
  fonts.forEach((font) => {
    const ext = extname(font.file);
    const outputExt = ext === '.ttf' || ext === '.otf' ? '.woff2' : ext;
    const fontPath = `/fonts/optimized/${basename(font.file, ext)}${outputExt}`;

    css += `@font-face {
  font-family: '${font.name}';
  src: url('${fontPath}') format('woff2');
  font-weight: ${font.weight};
  font-style: ${font.style};
  font-display: swap;
}\n\n`;
  });

  // Add emoji font rules if provided
  if (emojiCore) {
    css += `/* Emoji Fonts - Core Set */
@font-face {
  font-family: 'NotoColorEmoji';
  src: url('/fonts/optimized/noto-color-emoji-core.ttf') format('truetype');
  font-weight: normal;
  font-style: normal;
  font-display: swap;
}\n\n`;
  }

  // Add CSS custom properties
  css += `/* Font Stacks */
:root {
  --font-sans: 'GeistSans', system-ui, -apple-system, sans-serif;
  --font-mono: 'GeistMono', ui-monospace, monospace;
  --font-display: 'Doto', system-ui, sans-serif;
  --font-emoji: 'NotoColorEmoji', 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';
}\n`;

  return css;
}

async function main() {
  // console.log('🚀 Fast Font Optimization (Rust-based)\n');

  // Check if tools are available
  const tools = checkRustTools();
  const hasWoff2 = tools.woff2 === true;

  if (!hasWoff2) {
    // console.log('📥 woff2 tools not found. Installing...\n');
    const installed = installRustFontTools();
    if (!installed) {
      // console.error('❌ Could not install required tools');
      process.exit(1);
    }
  }

  // Create output directory
  mkdirSync(OPTIMIZED_FONTS_DIR, { recursive: true });

  const optimizedFonts = [];
  // const startTime = Date.now();

  // Process text fonts
  // console.log('📝 Optimizing text fonts...\n');
  for (const font of FONTS) {
    const inputPath = join(PUBLIC_FONTS_DIR, font.file);
    if (!existsSync(inputPath)) {
      // console.warn(`⚠️  Font not found: ${font.file}`);
      continue;
    }

    const ext = extname(font.file);
    const outputExt = ext === '.ttf' || ext === '.otf' ? '.woff2' : ext;
    const outputName = `${basename(font.file, ext)}${outputExt}`;
    const outputPath = join(OPTIMIZED_FONTS_DIR, outputName);

    // console.log(`Processing ${font.name}...`);
    const success = optimizeFontFast(inputPath, outputPath);

    if (success) {
      optimizedFonts.push(font);
      // console.log(`✅ ${font.name} optimized\n`);
    }
  }

  // Process emoji fonts
  const { core: emojiCore } = optimizeEmojiFont();

  // Generate optimized CSS
  // console.log('\n🎨 Generating optimized CSS...');
  const css = generateFontFaceCSS(optimizedFonts, emojiCore);
  writeFileSync(CSS_OUTPUT, css);
  // console.log(`✅ CSS written to: ${CSS_OUTPUT}`);

  // const endTime = Date.now();
  // const duration = ((endTime - startTime) / 1000).toFixed(2);

  // console.log(`\n✅ Font optimization complete in ${duration}s!`);
  // console.log('\n💡 Note: For full emoji font subsetting, consider using:');
  // console.log('   - hb-subset (from HarfBuzz) for color emoji fonts');
  // console.log('   - Or keep using the Python script for emoji fonts only');
}

main().catch((_e) => {
  // console.error(e);
  process.exit(1);
});
